  [FILE] build.gradle
  === Content of build.gradle ===
      plugins {
        id 'java'
        id 'application'
        id 'org.javamodularity.moduleplugin' version '1.8.12'
        id 'org.openjfx.javafxplugin' version '0.0.13'
        id 'org.beryx.jlink' version '2.25.0'
      }
      
      group 'com.MMP'
      version '1.0-SNAPSHOT'
      
      repositories {
        mavenCentral()
      }
      
      //This is the code i added, remove if it doesn't work
      java {
        toolchain {
          languageVersion = JavaLanguageVersion.of(20)
        }
      }
      
      ext {
        junitVersion = '5.9.2'
      }
      
      sourceCompatibility = '20'
      targetCompatibility = '20'
      
      tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
      }
      
      application {
        mainModule = 'com.mmp.mmp_javafx_test1'
        mainClass = 'com.mmp.mmp_javafx_test1.HelloApplication'
      }
      
      javafx {
        version = '20'
        modules = ['javafx.controls', 'javafx.fxml']
      }
      
      dependencies {
      
        testImplementation("org.junit.jupiter:junit-jupiter-api:${junitVersion}")
        testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:${junitVersion}")
      }
      
      test {
        useJUnitPlatform()  }
      
      jlink {
        imageZip = project.file("${buildDir}/distributions/app-${javafx.platform.classifier}.zip")
        options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']
        launcher {
          name = 'app'
        }
      }
      
      jlinkZip {
        group = 'distribution'
      }
  === END ===
  [FILE] gradlew
  === Content of gradlew ===
      #!/bin/sh
      
      #
      # Copyright Â© 2015-2021 the original authors.
      #
      # Licensed under the Apache License, Version 2.0 (the "License");
      # you may not use this file except in compliance with the License.
      # You may obtain a copy of the License at
      #
      #      https://www.apache.org/licenses/LICENSE-2.0
      #
      # Unless required by applicable law or agreed to in writing, software
      # distributed under the License is distributed on an "AS IS" BASIS,
      # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      # See the License for the specific language governing permissions and
      # limitations under the License.
      #
      
      ##############################################################################
      #
      #   Gradle start up script for POSIX generated by Gradle.
      #
      #   Important for running:
      #
      #   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
      #       noncompliant, but you have some other compliant shell such as ksh or
      #       bash, then to run this script, type that shell name before the whole
      #       command line, like:
      #
      #           ksh Gradle
      #
      #       Busybox and similar reduced shells will NOT work, because this script
      #       requires all of these POSIX shell features:
      #         * functions;
      #         * expansions Â«$varÂ», Â«${var}Â», Â«${var:-default}Â», Â«${var+SET}Â»,
      #           Â«${var#prefix}Â», Â«${var%suffix}Â», and Â«$( cmd )Â»;
      #         * compound commands having a testable exit status, especially Â«caseÂ»;
      #         * various built-in commands including Â«commandÂ», Â«setÂ», and Â«ulimitÂ».
      #
      #   Important for patching:
      #
      #   (2) This script targets any POSIX shell, so it avoids extensions provided
      #       by Bash, Ksh, etc; in particular arrays are avoided.
      #
      #       The "traditional" practice of packing multiple parameters into a
      #       space-separated string is a well documented source of bugs and security
      #       problems, so this is (mostly) avoided, by progressively accumulating
      #       options in "$@", and eventually passing that to Java.
      #
      #       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
      #       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
      #       see the in-line comments for details.
      #
      #       There are tweaks for specific operating systems such as AIX, CygWin,
      #       Darwin, MinGW, and NonStop.
      #
      #   (3) This script is generated from the Groovy template
      #       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
      #       within the Gradle project.
      #
      #       You can find Gradle at https://github.com/gradle/gradle/.
      #
      ##############################################################################
      
      # Attempt to set APP_HOME
      
      # Resolve links: $0 may be a link
      app_path=$0
      
      # Need this for daisy-chained symlinks.
      while
          APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
          [ -h "$app_path" ]
      do
          ls=$( ls -ld "$app_path" )
          link=${ls#*' -> '}
          case $link in             #(
            /*)   app_path=$link ;; #(
            *)    app_path=$APP_HOME$link ;;
          esac
      done
      
      APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit
      
      APP_NAME="Gradle"
      APP_BASE_NAME=${0##*/}
      
      # Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
      DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
      
      # Use the maximum available, or set MAX_FD != -1 to use that value.
      MAX_FD=maximum
      
      warn () {
          echo "$*"
      } >&2
      
      die () {
          echo
          echo "$*"
          echo
          exit 1
      } >&2
      
      # OS specific support (must be 'true' or 'false').
      cygwin=false
      msys=false
      darwin=false
      nonstop=false
      case "$( uname )" in                #(
        CYGWIN* )         cygwin=true  ;; #(
        Darwin* )         darwin=true  ;; #(
        MSYS* | MINGW* )  msys=true    ;; #(
        NONSTOP* )        nonstop=true ;;
      esac
      
      CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
      
      
      # Determine the Java command to use to start the JVM.
      if [ -n "$JAVA_HOME" ] ; then
          if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
              # IBM's JDK on AIX uses strange locations for the executables
              JAVACMD=$JAVA_HOME/jre/sh/java
          else
              JAVACMD=$JAVA_HOME/bin/java
          fi
          if [ ! -x "$JAVACMD" ] ; then
              die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
      
      Please set the JAVA_HOME variable in your environment to match the
      location of your Java installation."
          fi
      else
          JAVACMD=java
          which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
      
      Please set the JAVA_HOME variable in your environment to match the
      location of your Java installation."
      fi
      
      # Increase the maximum file descriptors if we can.
      if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
          case $MAX_FD in #(
            max*)
              MAX_FD=$( ulimit -H -n ) ||
                  warn "Could not query maximum file descriptor limit"
          esac
          case $MAX_FD in  #(
            '' | soft) :;; #(
            *)
              ulimit -n "$MAX_FD" ||
                  warn "Could not set maximum file descriptor limit to $MAX_FD"
          esac
      fi
      
      # Collect all arguments for the java command, stacking in reverse order:
      #   * args from the command line
      #   * the main class name
      #   * -classpath
      #   * -D...appname settings
      #   * --module-path (only if needed)
      #   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.
      
      # For Cygwin or MSYS, switch paths to Windows format before running java
      if "$cygwin" || "$msys" ; then
          APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
          CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
      
          JAVACMD=$( cygpath --unix "$JAVACMD" )
      
          # Now convert the arguments - kludge to limit ourselves to /bin/sh
          for arg do
              if
                  case $arg in                                #(
                    -*)   false ;;                            # don't mess with options #(
                    /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                          [ -e "$t" ] ;;                      #(
                    *)    false ;;
                  esac
              then
                  arg=$( cygpath --path --ignore --mixed "$arg" )
              fi
              # Roll the args list around exactly as many times as the number of
              # args, so each arg winds up back in the position where it started, but
              # possibly modified.
              #
              # NB: a `for` loop captures its iteration list before it begins, so
              # changing the positional parameters here affects neither the number of
              # iterations, nor the values presented in `arg`.
              shift                   # remove old arg
              set -- "$@" "$arg"      # push replacement arg
          done
      fi
      
      # Collect all arguments for the java command;
      #   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
      #     shell script including quotes and variable substitutions, so put them in
      #     double quotes to make sure that they get re-expanded; and
      #   * put everything else in single quotes, so that it's not re-expanded.
      
      set -- \
              "-Dorg.gradle.appname=$APP_BASE_NAME" \
              -classpath "$CLASSPATH" \
              org.gradle.wrapper.GradleWrapperMain \
              "$@"
      
      # Use "xargs" to parse quoted args.
      #
      # With -n1 it outputs one arg per line, with the quotes and backslashes removed.
      #
      # In Bash we could simply go:
      #
      #   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
      #   set -- "${ARGS[@]}" "$@"
      #
      # but POSIX shell has neither arrays nor command substitution, so instead we
      # post-process each arg (as a line of input to sed) to backslash-escape any
      # character that might be a shell metacharacter, then use eval to reverse
      # that process (while maintaining the separation between arguments), and wrap
      # the whole thing up as a single "set" statement.
      #
      # This will of course break if any of these variables contains a newline or
      # an unmatched quote.
      #
      
      eval "set -- $(
              printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
              xargs -n1 |
              sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
              tr '\n' ' '
          )" '"$@"'
      
      exec "$JAVACMD" "$@"
      
  === END ===
  [FILE] gradlew.bat
  === Content of gradlew.bat ===
      @rem
      @rem Copyright 2015 the original author or authors.
      @rem
      @rem Licensed under the Apache License, Version 2.0 (the "License");
      @rem you may not use this file except in compliance with the License.
      @rem You may obtain a copy of the License at
      @rem
      @rem      https://www.apache.org/licenses/LICENSE-2.0
      @rem
      @rem Unless required by applicable law or agreed to in writing, software
      @rem distributed under the License is distributed on an "AS IS" BASIS,
      @rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      @rem See the License for the specific language governing permissions and
      @rem limitations under the License.
      @rem
      
      @if "%DEBUG%" == "" @echo off
      @rem ##########################################################################
      @rem
      @rem  Gradle startup script for Windows
      @rem
      @rem ##########################################################################
      
      @rem Set local scope for the variables with windows NT shell
      if "%OS%"=="Windows_NT" setlocal
      
      set DIRNAME=%~dp0
      if "%DIRNAME%" == "" set DIRNAME=.
      set APP_BASE_NAME=%~n0
      set APP_HOME=%DIRNAME%
      
      @rem Resolve any "." and ".." in APP_HOME to make it shorter.
      for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
      
      @rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
      set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
      
      @rem Find java.exe
      if defined JAVA_HOME goto findJavaFromJavaHome
      
      set JAVA_EXE=java.exe
      %JAVA_EXE% -version >NUL 2>&1
      if "%ERRORLEVEL%" == "0" goto execute
      
      echo.
      echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
      echo.
      echo Please set the JAVA_HOME variable in your environment to match the
      echo location of your Java installation.
      
      goto fail
      
      :findJavaFromJavaHome
      set JAVA_HOME=%JAVA_HOME:"=%
      set JAVA_EXE=%JAVA_HOME%/bin/java.exe
      
      if exist "%JAVA_EXE%" goto execute
      
      echo.
      echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
      echo.
      echo Please set the JAVA_HOME variable in your environment to match the
      echo location of your Java installation.
      
      goto fail
      
      :execute
      @rem Setup the command line
      
      set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
      
      
      @rem Execute Gradle
      "%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
      
      :end
      @rem End local scope for the variables with windows NT shell
      if "%ERRORLEVEL%"=="0" goto mainEnd
      
      :fail
      rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
      rem the _cmd.exe /c_ return code!
      if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
      exit /b 1
      
      :mainEnd
      if "%OS%"=="Windows_NT" endlocal
      
      :omega
      
  === END ===
  [FILE] MMP_JavaFX_test1.iml
  === Content of MMP_JavaFX_test1.iml ===
      <?xml version="1.0" encoding="UTF-8"?>
      <module type="JAVA_MODULE" version="4">
        <component name="NewModuleRootManager" inherit-compiler-output="true">
          <exclude-output />
          <content url="file://$MODULE_DIR$">
            <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
          </content>
          <orderEntry type="inheritedJdk" />
          <orderEntry type="sourceFolder" forTests="false" />
          <orderEntry type="library" exported="" name="MMP_JavaFX_test1-1.0-SNAPSHOT" level="project" />
          <orderEntry type="library" exported="" name="gradle-wrapper" level="project" />
        </component>
      </module>
  === END ===
  [FILE] settings.gradle
  === Content of settings.gradle ===
      rootProject.name = "MMP_JavaFX_test1"
  === END ===
  [DIR] build
    [DIR] classes
      [DIR] java
        [DIR] main
          [DIR] com
            [DIR] mmp
              [DIR] mmp_javafx_test1
    [DIR] generated
      [DIR] sources
        [DIR] annotationProcessor
          [DIR] java
            [DIR] main
        [DIR] headers
          [DIR] java
            [DIR] main
    [DIR] libs
    [DIR] resources
      [DIR] main
        [DIR] com
          [DIR] mmp
            [DIR] mmp_javafx_test1
              [FILE] hello-view.fxml
              === Content of build\resources\main\com\mmp\mmp_javafx_test1\hello-view.fxml ===
                  <?xml version="1.0" encoding="UTF-8"?>
                  
                  <?import javafx.scene.layout.VBox?>
                  <?import javafx.scene.control.Button?>
                  <?import javafx.scene.control.Label?>
                  <?import javafx.geometry.Insets?>
                  
                  <VBox alignment="CENTER" spacing="20.0" xmlns:fx="http://javafx.com/fxml"
                        fx:controller="com.mmp.mmp_javafx_test1.HelloController">
                    <padding>
                      <Insets bottom="20.0" left="20.0" right="20.0" top="20.0"/>
                    </padding>
                  
                    <Label fx:id="welcomeText" text="Maze Generator"/>
                    <Button text="Generate New Maze" onAction="#generateNewMaze"/>
                  </VBox>
              === END ===
    [DIR] tmp
      [DIR] compileJava
        [DIR] compileTransaction
          [DIR] backup-dir
          [DIR] stash-dir
            [FILE] HelloApplication.class.uniqueId2
            === Content of build\tmp\compileJava\compileTransaction\stash-dir\HelloApplication.class.uniqueId2 ===
                   @ 
                      javafx/application/Application <init> ()V  javafx/fxml/FXMLLoader 
                 )com/mmp/mmp_javafx_test1/HelloApplication  hello-view.fxml
                      java/lang/Class getResource "(Ljava/lang/String;)Ljava/net/URL;
                     (Ljava/net/URL;)V  javafx/scene/Scene
                     load ()Ljava/lang/Object;  javafx/scene/Parent@      @     
                  #  $ (Ljavafx/scene/Parent;DD)V & Maze Generator
                 ( ) * + , javafx/stage/Stage setTitle (Ljava/lang/String;)V
                 ( . / 0 setScene (Ljavafx/scene/Scene;)V 2 &com/mmp/mmp_javafx_test1/MazeGenerator
                 1 4  5 (II)V
                 1 7 8 9 generate "()Lcom/mmp/mmp_javafx_test1/Graph; ; !com/mmp/mmp_javafx_test1/MazeGrid
                 : =  > &(Lcom/mmp/mmp_javafx_test1/Graph;III)V @ #com/mmp/mmp_javafx_test1/Graph$Node
                 ? 4
                 : C D E setStartNode ((Lcom/mmp/mmp_javafx_test1/Graph$Node;)V
                 : G H E 
                setEndNode J $com/mmp/mmp_javafx_test1/AStarSolver
                 I L  M m(Lcom/mmp/mmp_javafx_test1/Graph;Lcom/mmp/mmp_javafx_test1/Graph$Node;Lcom/mmp/mmp_javafx_test1/Graph$Node;)V
                 I O P Q findPath ()Ljava/util/List;
                 : S T U 
                highlightPath (Ljava/util/List;)V
                  W X Y getRoot ()Ljavafx/scene/Parent; [ javafx/scene/layout/VBox
                 Z ] ^ _ getChildren %()Ljavafx/collections/ObservableList; a b c d e !javafx/collections/ObservableList add (Ljava/lang/Object;)Z
                 ( g h  show j java/lang/String
                 	 l m n launch ([Ljava/lang/String;)V Code LineNumberTable LocalVariableTable this +Lcom/mmp/mmp_javafx_test1/HelloApplication; start (Ljavafx/stage/Stage;)V stage Ljavafx/stage/Stage; 
                fxmlLoader Ljavafx/fxml/FXMLLoader; scene Ljavafx/scene/Scene; 	generator (Lcom/mmp/mmp_javafx_test1/MazeGenerator; 	mazeGraph  Lcom/mmp/mmp_javafx_test1/Graph; mazeGrid #Lcom/mmp/mmp_javafx_test1/MazeGrid; %Lcom/mmp/mmp_javafx_test1/Graph$Node; end solver &Lcom/mmp/mmp_javafx_test1/AStarSolver; path Ljava/util/List; root Ljavafx/scene/layout/VBox; LocalVariableTypeTable 7Ljava/util/List<Lcom/mmp/mmp_javafx_test1/Graph$Node;>; 
                Exceptions  java/io/IOException main args [Ljava/lang/String; 
                SourceFile HelloApplication.java InnerClasses  com/mmp/mmp_javafx_test1/Graph Node ! 	           o   /     *     p        q        r s    t u  o        Y	 
                 M Y,      "N+% '+- - 1Y 3: 6: :Y <: ?Y A: ?Y A: B F IY K:		 N:
                
                 R- V Z: \ ` W+ f    p   J       $  *  /  <  C  T  _  l  s   z #  $  %  (  )  +  , q   z     r s      v w    x y  $  z {  < v | }  C o ~   T ^    _ S t   l F     )   	  "   
                            "   
                       	  n  o   6      i k    p   
                    /  0 q                     
                  ?   	
            === END ===
            [FILE] MazeCell.class.uniqueId1
            === Content of build\tmp\compileJava\compileTransaction\stash-dir\MazeCell.class.uniqueId1 ===
                   @ e
                      javafx/scene/layout/StackPane <init> ()V	  	 
                   !com/mmp/mmp_javafx_test1/MazeCell node %Lcom/mmp/mmp_javafx_test1/Graph$Node;	     size I  -fx-background-color: white;
                     setStyle (Ljava/lang/String;)V
                     setPrefSize (DD)V  javafx/scene/layout/Border   javafx/scene/layout/BorderStroke	   ! " # $ javafx/scene/paint/Color BLACK Ljavafx/scene/paint/Color;	 & ' ( ) * %javafx/scene/layout/BorderStrokeStyle SOLID 'Ljavafx/scene/layout/BorderStrokeStyle;	 , - . / 0 javafx/scene/layout/CornerRadii EMPTY !Ljavafx/scene/layout/CornerRadii;	 2 3 4 5 6  javafx/scene/layout/BorderWidths DEFAULT "Ljavafx/scene/layout/BorderWidths;
                  8  9 (Ljavafx/scene/paint/Paint;Ljavafx/scene/layout/BorderStrokeStyle;Ljavafx/scene/layout/CornerRadii;Ljavafx/scene/layout/BorderWidths;)V
                  ;  < &([Ljavafx/scene/layout/BorderStroke;)V
                  > ? @ 	setBorder (Ljavafx/scene/layout/Border;)V	  B C D 	topBorder "Ljavafx/scene/layout/BorderStroke;	  F G D rightBorder	  I J D bottomBorder	  L M D 
                leftBorder O -fx-background-color: green; Q -fx-background-color: blue; S -fx-background-color: red; )(Lcom/mmp/mmp_javafx_test1/Graph$Node;I)V Code LineNumberTable LocalVariableTable this #Lcom/mmp/mmp_javafx_test1/MazeCell; 
                markAsPath markAsStart 	markAsEnd 
                SourceFile 
                MazeCell.java InnerClasses a #com/mmp/mmp_javafx_test1/Graph$Node c com/mmp/mmp_javafx_test1/Graph Node !                 C D    J D    M D    G D      T  U   
                    * *+ * 
                * * * Y Y Y  % + 1 7S : =* Y Y* Y  % + 1 7Z ASY* Y  % + 1 7Z ESY* Y  % + 1 7Z HSY* Y  % + 1 7Z KS : =    V   "       	        A   # W         X Y                Z   U   5     *N     V   
                    '  ( W        X Y    [   U   5     *P     V   
                    +  , W        X Y    \   U   5     *R     V   
                    /  0 W        X Y    ]    ^ _   
                  ` b d 	
            === END ===
            [FILE] MazeGrid.class.uniqueId0
            === Content of build\tmp\compileJava\compileTransaction\stash-dir\MazeGrid.class.uniqueId0 ===
                   @ 
                      javafx/scene/layout/GridPane <init> ()V  java/util/HashMap
                  	   
                   !com/mmp/mmp_javafx_test1/MazeGrid cellMap Ljava/util/Map;	     cellSize I  #com/mmp/mmp_javafx_test1/Graph$Node
                     (II)V  !com/mmp/mmp_javafx_test1/MazeCell
                     )(Lcom/mmp/mmp_javafx_test1/Graph$Node;I)V    ! " # 
                java/util/Map put 8(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
                  % & ' add (Ljavafx/scene/Node;II)V	 ) * + ,  com/mmp/mmp_javafx_test1/Graph 
                adjacencyList  . / 0 keySet ()Ljava/util/Set; 2 3 4 5 6 
                java/util/Set iterator ()Ljava/util/Iterator; 8 9 : ; < java/util/Iterator hasNext ()Z 8 > ? @ next ()Ljava/lang/Object;  B C D containsKey (Ljava/lang/Object;)Z
                 ) F G H getNeighbors 7(Lcom/mmp/mmp_javafx_test1/Graph$Node;)Ljava/util/List; J 3 K java/util/List   M N O accept B(Lcom/mmp/mmp_javafx_test1/MazeGrid;)Ljava/util/function/Consumer; J Q R S forEach  (Ljava/util/function/Consumer;)V  U V W get &(Ljava/lang/Object;)Ljava/lang/Object;
                  Y Z  markAsStart
                  \ ]  	markAsEnd
                  _ `  
                markAsPath 	Signature YLjava/util/Map<Lcom/mmp/mmp_javafx_test1/Graph$Node;Lcom/mmp/mmp_javafx_test1/MazeCell;>; &(Lcom/mmp/mmp_javafx_test1/Graph;III)V Code LineNumberTable LocalVariableTable node %Lcom/mmp/mmp_javafx_test1/Graph$Node; cell #Lcom/mmp/mmp_javafx_test1/MazeCell; x y neighbor this #Lcom/mmp/mmp_javafx_test1/MazeGrid; graph  Lcom/mmp/mmp_javafx_test1/Graph; width height 
                StackMapTable 
                highlightPath (Ljava/util/List;)V path Ljava/util/List; LocalVariableTypeTable 7Ljava/util/List<Lcom/mmp/mmp_javafx_test1/Graph$Node;>; :(Ljava/util/List<Lcom/mmp/mmp_javafx_test1/Graph$Node;>;)V setStartNode ((Lcom/mmp/mmp_javafx_test1/Graph$Node;)V start 
                setEndNode end lambda$highlightPath$0 
                SourceFile 
                MazeGrid.java BootstrapMethods 
                      "java/lang/invoke/LambdaMetafactory metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;  (Ljava/lang/Object;)V 
                    } } InnerClasses Node  %java/lang/invoke/MethodHandles$Lookup  java/lang/invoke/MethodHandles Lookup !          a    b         c  d    	   * * Y 	 
                * 6 J6 ; Y : Y :* 
                  W* $Å„+ ( -  1 : 7  T =  :* 
                 A  7+ E I : 7    =  :* 
                 A  Ü§    e   J             '  4  A  O  Y  _  e "  #  $  %  (  *  - f   p  4 % g h  A  i j  ! > k    M l     m h   B g h     n o      p q     r      s         t   3 	    )    =   8 0  8#    u v  d   W     
                +* L   P     e   
                    0  5 f       
                 n o     
                 w x  y       
                 w z  a    {  | }  d   c     * 
                + A  * 
                + T   X    e       8 
                 9  ; f        n o      ~ h  t       }  d   c     * 
                + A  * 
                + T   [    e       > 
                 ?  A f        n o       h  t      }  d   c     * 
                + A  * 
                + T   ^    e       1 
                 2  4 f        n o      g h  t                           )  	    
            === END ===
            [FILE] module-info.class.uniqueId3
            === Content of build\tmp\compileJava\compileTransaction\stash-dir\module-info.class.uniqueId3 ===
                   @   module-info 
                SourceFile module-info.java Module  com.mmp.mmp_javafx_test1 1.0-SNAPSHOT 
                 	java.base 20.0.2.1 
                 javafx.controls 20  javafx.fxml  com/mmp/mmp_javafx_test1 )com/mmp/mmp_javafx_test1/HelloApplication  ModuleMainClass                    0      	                               
            === END ===
      [DIR] jar
        [FILE] MANIFEST.MF
        === Content of build\tmp\jar\MANIFEST.MF ===
            Manifest-Version: 1.0
            
            
        === END ===
  [DIR] gradle
    [DIR] wrapper
      [FILE] gradle-wrapper.properties
      === Content of gradle\wrapper\gradle-wrapper.properties ===
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          
          
          
      === END ===
  [DIR] out
    [DIR] production
      [DIR] MMP maze project
  [DIR] src
    [DIR] main
      [DIR] java
        [FILE] module-info.java
        === Content of src\main\java\module-info.java ===
            module com.mmp.mmp_javafx_test1 {
                requires javafx.controls;
                requires javafx.fxml;
                        
                                        
                opens com.mmp.mmp_javafx_test1 to javafx.fxml;
                exports com.mmp.mmp_javafx_test1;
            }
        === END ===
        [DIR] com
          [DIR] mmp
            [DIR] mmp_javafx_test1
              [FILE] AStarSolver.java
              === Content of src\main\java\com\mmp\mmp_javafx_test1\AStarSolver.java ===
                  package com.mmp.mmp_javafx_test1;
                  
                  import java.util.*;
                  
                  public class AStarSolver {
                      private final Graph graph;
                      private final Graph.Node start, end;
                  
                      public AStarSolver(Graph graph, Graph.Node start, Graph.Node end) {
                          this.graph = graph;
                          this.start = start;
                          this.end = end;
                      }
                  
                      // Add this method to calculate heuristic (Manhattan distance)
                      private int heuristic(Graph.Node a, Graph.Node b) {
                          return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
                      }
                  
                      //uses lambda to priotitise by g, this is a placeholder for when i upgrade from djkstra to A*
                      public List<Graph.Node> findPath() {
                          PriorityQueue<NodeWrapper> openSet = new PriorityQueue<>(Comparator.comparingInt(n -> n.f));
                          Map<Graph.Node, NodeWrapper> allNodes = new HashMap<>();
                  
                          NodeWrapper startWrapper = new NodeWrapper(start, 0, end);
                          openSet.add(startWrapper);
                          allNodes.put(start, startWrapper);
                  
                          while (!openSet.isEmpty()) {
                              NodeWrapper current = openSet.poll();
                              if (current.node.equals(end)) {
                                  return reconstructPath(current);
                              }
                  
                              for (Graph.Node neighbor : graph.getNeighbors(current.node)) {
                                  int tentativeG = current.g + 1;
                                  NodeWrapper neighborWrapper = allNodes.computeIfAbsent(neighbor,
                                          n -> new NodeWrapper(n, Integer.MAX_VALUE, end));
                  
                                  if (tentativeG < neighborWrapper.g) {
                                      neighborWrapper.g = tentativeG;
                                      neighborWrapper.f = tentativeG + heuristic(neighbor, end);
                                      neighborWrapper.parent = current;
                  
                                      if (!openSet.contains(neighborWrapper)) {
                                          openSet.add(neighborWrapper);
                                      }
                                  }
                              }
                          }
                          return Collections.emptyList();
                      }
                  
                      private List<Graph.Node> reconstructPath(NodeWrapper node) {
                          List<Graph.Node> path = new ArrayList<>();
                          while (node != null) {
                              path.add(node.node);
                              node = node.parent;
                          }
                          Collections.reverse(path);
                          return path;
                      }
                  
                      //static to keep seperate from graph class
                      //nodes can exist seperately from graph
                      //doesn't need an instace of graph
                      //adjaceny lists are handeled seperate from the node class
                      private class NodeWrapper {
                          Graph.Node node;
                          int g; // Cost from start
                          int f; // Total cost (g + h)
                          NodeWrapper parent;
                  
                          NodeWrapper(Graph.Node node, int g, Graph.Node end) {
                              this.node = node;
                              this.g = g;
                              this.f = g + heuristic(node, end);
                          }
                      }
                  }
              === END ===
              [FILE] Graph.java
              === Content of src\main\java\com\mmp\mmp_javafx_test1\Graph.java ===
                  package com.mmp.mmp_javafx_test1;
                  
                  import java.util.*;
                  
                  public class Graph {
                  
                      //Need to be able to explain
                      final Map<Node, List<Node>> adjacencyList = new HashMap<>();
                  
                      // Adds a bidirectional edge between two nodes (maze paths are undirected)
                  
                  
                  
                     //The use of Lambda functions in my code was inspired by
                      public void addEdge(Node node1, Node node2) {
                          adjacencyList.computeIfAbsent(node1, k -> new ArrayList<>()).add(node2);
                          adjacencyList.computeIfAbsent(node2, k -> new ArrayList<>()).add(node1);
                          // Add both ways
                      }
                  
                      // Returns all neighbors of a node (connected maze paths)
                      public List<Node> getNeighbors(Node node) {
                          return adjacencyList.getOrDefault(node, new ArrayList<>()); // Return empty list if no neighbors
                      }
                  
                      // Represents a maze cell/node with coordinates (x,y)
                      public static class Node {
                          final int x;
                          final int y;
                  
                          public Node(int x, int y) {
                              this.x = x;
                              this.y = y;
                          }
                  
                          // Equality based on coordinates for proper hashing in adjacencyList
                          @Override
                          public boolean equals(Object o) {
                              if (this == o) return true;
                              if (o == null || getClass() != o.getClass()) return false;
                              Node node = (Node) o;
                              return x == node.x && y == node.y;
                          }
                  
                          // HashCode uses coordinates to ensure consistent hashing
                          @Override
                          public int hashCode() {
                              return Objects.hash(x, y);
                          }
                      }
                  }
              === END ===
              [FILE] HelloApplication.java
              === Content of src\main\java\com\mmp\mmp_javafx_test1\HelloApplication.java ===
                  package com.mmp.mmp_javafx_test1;
                  
                  import javafx.application.Application;
                  import javafx.fxml.FXMLLoader;
                  import javafx.scene.Scene;
                  import javafx.scene.layout.VBox;
                  import javafx.stage.Stage;
                  
                  import java.io.IOException;
                  import java.util.List;
                  
                  public class HelloApplication extends Application {
                  
                      @Override
                      public void start(Stage stage) throws IOException {
                          FXMLLoader fxmlLoader = new FXMLLoader(HelloApplication.class.getResource("hello-view.fxml"));
                          Scene scene = new Scene(fxmlLoader.load(), 800, 600);
                          stage.setTitle("Maze Generator");
                          stage.setScene(scene);
                  
                          // Generate maze
                          MazeGenerator generator = new MazeGenerator(20, 15);
                          Graph mazeGraph = generator.generate();
                  
                          // Create maze grid
                          MazeGrid mazeGrid = new MazeGrid(mazeGraph, 20, 15, 30);
                  
                          // Set start and end nodes
                          Graph.Node start = new Graph.Node(0, 0);
                          Graph.Node end = new Graph.Node(19, 14);
                          mazeGrid.setStartNode(start);
                          mazeGrid.setEndNode(end);
                  
                          // Solve maze
                          AStarSolver solver = new AStarSolver(mazeGraph, start, end);
                          List<Graph.Node> path = solver.findPath();
                          mazeGrid.highlightPath(path);
                  
                          // Add to scene
                          VBox root = (VBox) scene.getRoot();
                          root.getChildren().add(mazeGrid);
                  
                          stage.show();
                      }
                  
                      public static void main(String[] args) {
                          launch();
                      }
                  }
              === END ===
              [FILE] HelloController.java
              === Content of src\main\java\com\mmp\mmp_javafx_test1\HelloController.java ===
                  
                  /* Old code, Change this back it it doesnt work
                  package com.mmp.mmp_javafx_test1;
                  
                  import javafx.fxml.FXML;
                  import javafx.scene.control.Label;
                  
                  public class HelloController {
                      @FXML
                      private Label welcomeText;
                  
                      @FXML
                      protected void onHelloButtonClick() {
                          welcomeText.setText("Welcome to JavaFX Application!");
                      }
                  }
                  */
                  // src/main/java/com/mmp/mmp_javafx_test1/HelloController.java
                  package com.mmp.mmp_javafx_test1;
                  
                  import javafx.fxml.FXML;
                  import javafx.scene.control.Label;
                  import javafx.scene.layout.GridPane;
                  import javafx.scene.shape.Rectangle;
                  import javafx.scene.paint.Color;
                  
                  public class HelloController {
                      @FXML
                      private Label welcomeText;
                  
                      private HelloApplication application;
                  
                      public void setApplication(HelloApplication application) {
                          this.application = application;
                      }
                  
                      @FXML
                      protected void generateNewMaze() {
                          // Implement new maze generation logic
                          welcomeText.setText("New maze generated!");
                      }
                  }
              === END ===
              [FILE] MazeCell.java
              === Content of src\main\java\com\mmp\mmp_javafx_test1\MazeCell.java ===
                  
                  package com.mmp.mmp_javafx_test1;
                  import javafx.application.Application;
                  import javafx.fxml.FXMLLoader;
                  import javafx.scene.Scene;
                  import javafx.scene.layout.*;
                  import javafx.scene.paint.Color;
                  import javafx.stage.Stage;
                  
                  
                  
                  // MazeCell.java
                  public class MazeCell extends StackPane {
                      private final Graph.Node node;
                      private final int size;
                  
                      public MazeCell(Graph.Node node, int size) {
                          this.node = node;
                          this.size = size;
                          setStyle("-fx-background-color: white;");
                          setPrefSize(size, size);
                  
                          // Initialize borders to ALL SIDES (will be adjusted later)
                          setBorder(new Border(
                                  createBorder(Color.BLACK),  // Top
                                  createBorder(Color.BLACK),  // Right
                                  createBorder(Color.BLACK),  // Bottom
                                  createBorder(Color.BLACK)   // Left
                          ));
                      }
                  
                      // Helper method to create border strokes
                      private BorderStroke createBorder(Color color) {
                          return new BorderStroke(
                                  color,
                                  BorderStrokeStyle.SOLID,
                                  CornerRadii.EMPTY,
                                  BorderWidths.DEFAULT
                          );
                      }
                  
                      // Method to update borders (called by MazeGrid)
                      public void updateBorders(boolean top, boolean right, boolean bottom, boolean left) {
                          setBorder(new Border(
                                  createBorder(top ? Color.BLACK : Color.TRANSPARENT),
                                  createBorder(right ? Color.BLACK : Color.TRANSPARENT),
                                  createBorder(bottom ? Color.BLACK : Color.TRANSPARENT),
                                  createBorder(left ? Color.BLACK : Color.TRANSPARENT)
                          ));
                      }
                  
                      // Existing markAsPath, markAsStart, markAsEnd remain
                      // ...
                  
                  
                      public void markAsPath() {
                          setStyle("-fx-background-color: green;");
                      }
                  
                      public void markAsStart() {
                          setStyle("-fx-background-color: blue;");
                      }
                  
                      public void markAsEnd() {
                          setStyle("-fx-background-color: red;");
                      }
                  
                  
                  }
                  
                  // MazeGrid.java
                  
              === END ===
              [FILE] MazeGenerator.java
              === Content of src\main\java\com\mmp\mmp_javafx_test1\MazeGenerator.java ===
                  package com.mmp.mmp_javafx_test1;
                  
                  import java.util.ArrayList;
                  import java.util.List;
                  import java.util.Random;
                  import java.util.Stack;
                  
                  public class MazeGenerator {
                      private final int width, height;
                      private final boolean[][] visited; // Tracks visited cells during generation
                      private final Graph graph = new Graph(); // Stores maze structure
                  
                      public MazeGenerator(int width, int height) {
                          this.width = width;
                          this.height = height;
                          this.visited = new boolean[height][width]; // Initialize visitation grid
                      }
                  
                      // Generates a maze using recursive backtracking algorithm
                      public Graph generate() {
                          Random rand = new Random();
                          Stack<Graph.Node> stack = new Stack<>();
                          Graph.Node start = new Graph.Node(0, 0);
                          visited[0][0] = true;
                          stack.push(start);
                  
                          while (!stack.isEmpty()) {
                              Graph.Node current = stack.pop(); // Backtracking step
                              List<Graph.Node> neighbors = getUnvisitedNeighbors(current);
                  
                              if (!neighbors.isEmpty()) {
                                  stack.push(current); // Push current back to backtrack later
                                  Graph.Node next = neighbors.get(rand.nextInt(neighbors.size())); // Random neighbor
                                  graph.addEdge(current, next); // Create path between nodes
                                  visited[next.y][next.x] = true; // Mark as visited
                                  stack.push(next); // Continue exploring from new node
                              }
                          }
                          return graph;
                      }
                  
                      // Finds unvisited neighbors in all 4 directions (up, down, left, right)
                      private List<Graph.Node> getUnvisitedNeighbors(Graph.Node node) {
                          List<Graph.Node> neighbors = new ArrayList<>();
                          int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up
                  
                          for (int[] dir : directions) {
                              int nx = node.x + dir[0];
                              int ny = node.y + dir[1];
                  
                              if (nx >= 0 && ny >= 0 && nx < width && ny < height && !visited[ny][nx]) {
                                  neighbors.add(new Graph.Node(nx, ny));
                              }
                          }
                          return neighbors;
                      }
                  }
              === END ===
              [FILE] MazeGrid.java
              === Content of src\main\java\com\mmp\mmp_javafx_test1\MazeGrid.java ===
                  package com.mmp.mmp_javafx_test1;
                  
                  import javafx.scene.layout.GridPane;
                  import javafx.application.Application;
                  import javafx.fxml.FXMLLoader;
                  import javafx.scene.Scene;
                  import javafx.scene.layout.*;
                  import javafx.scene.paint.Color;
                  import javafx.stage.Stage;
                  
                  
                  import java.util.HashMap;
                  import java.util.List;
                  import java.util.Map;
                  
                  
                  public class MazeGrid extends GridPane {
                      private final Map<Graph.Node, MazeCell> cellMap = new HashMap<>();
                      private final int cellSize;
                  
                      public MazeGrid(Graph graph, int width, int height, int cellSize) {
                          this.cellSize = cellSize;
                  
                          // Initialize grid cells
                          for (int y = 0; y < height; y++) {
                              for (int x = 0; x < width; x++) {
                                  Graph.Node node = new Graph.Node(x, y);
                                  MazeCell cell = new MazeCell(node, cellSize);
                                  cellMap.put(node, cell);
                                  add(cell, x, y);
                              }
                          }
                  
                          // === NEW LOGIC TO REMOVE CORRECT WALLS ===
                          for (Map.Entry<Graph.Node, MazeCell> entry : cellMap.entrySet()) {
                              Graph.Node node = entry.getKey();
                              MazeCell cell = entry.getValue();
                  
                              boolean hasRightWall = true;
                              boolean hasBottomWall = true;
                              boolean hasLeftWall = true;
                              boolean hasTopWall = true;
                  
                              // Check right neighbor
                              if (node.x + 1 < width) {
                                  Graph.Node rightNode = new Graph.Node(node.x + 1, node.y);
                                  if (graph.getNeighbors(node).contains(rightNode)) {
                                      hasRightWall = false;
                                  }
                              }
                  
                              // Check bottom neighbor
                              if (node.y + 1 < height) {
                                  Graph.Node bottomNode = new Graph.Node(node.x, node.y + 1);
                                  if (graph.getNeighbors(node).contains(bottomNode)) {
                                      hasBottomWall = false;
                                  }
                              }
                  
                              // Check left neighbor
                              if (node.x - 1 >= 0) {
                                  Graph.Node leftNode = new Graph.Node(node.x - 1, node.y);
                                  if (graph.getNeighbors(node).contains(leftNode)) {
                                      hasLeftWall = false;
                                  }
                              }
                  
                              // Check top neighbor
                              if (node.y - 1 >= 0) {
                                  Graph.Node topNode = new Graph.Node(node.x, node.y - 1);
                                  if (graph.getNeighbors(node).contains(topNode)) {
                                      hasTopWall = false;
                                  }
                              }
                  
                              // Update cell borders based on adjacency
                              cell.updateBorders(hasTopWall, hasRightWall, hasBottomWall, hasLeftWall);
                          }
                      }
                  
                      // Existing highlightPath, setStartNode, setEndNode methods remain
                      // ...
                  
                  
                      private BorderStroke createBorder() {
                          return new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                      }
                  
                      private BorderStroke createTransparent() {
                          return new BorderStroke(Color.TRANSPARENT, BorderStrokeStyle.NONE, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                      }
                  
                      public void highlightPath(List<Graph.Node> path) {
                          path.forEach(node -> {
                              if (cellMap.containsKey(node)) {
                                  cellMap.get(node).markAsPath();
                              }
                          });
                      }
                  
                      public void setStartNode(Graph.Node start) {
                          if (cellMap.containsKey(start)) {
                              cellMap.get(start).markAsStart();
                          }
                      }
                  
                      public void setEndNode(Graph.Node end) {
                          if (cellMap.containsKey(end)) {
                              cellMap.get(end).markAsEnd();
                          }
                      }
                  
                  }
              === END ===
      [DIR] resources
        [DIR] com
          [DIR] mmp
            [DIR] mmp_javafx_test1
              [FILE] hello-view.fxml
              === Content of src\main\resources\com\mmp\mmp_javafx_test1\hello-view.fxml ===
                  <?xml version="1.0" encoding="UTF-8"?>
                  
                  <?import javafx.scene.layout.VBox?>
                  <?import javafx.scene.control.Button?>
                  <?import javafx.scene.control.Label?>
                  <?import javafx.geometry.Insets?>
                  
                  <VBox alignment="CENTER" spacing="20.0" xmlns:fx="http://javafx.com/fxml"
                        fx:controller="com.mmp.mmp_javafx_test1.HelloController">
                    <padding>
                      <Insets bottom="20.0" left="20.0" right="20.0" top="20.0"/>
                    </padding>
                  
                    <Label fx:id="welcomeText" text="Maze Generator"/>
                    <Button text="Generate New Maze" onAction="#generateNewMaze"/>
                  </VBox>
              === END ===