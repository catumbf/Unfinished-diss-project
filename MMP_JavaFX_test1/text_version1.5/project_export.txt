  [FILE] build.gradle
  === Content of build.gradle ===
      plugins {
        id 'java'
        id 'application'
        id 'org.javamodularity.moduleplugin' version '1.8.12'
        id 'org.openjfx.javafxplugin' version '0.0.13'
        id 'org.beryx.jlink' version '2.25.0'
      }
      
      group 'com.MMP'
      version '1.0-SNAPSHOT'
      
      repositories {
        mavenCentral()
      }
      
      //This is the code i added, remove if it doesn't work
      java {
        toolchain {
          languageVersion = JavaLanguageVersion.of(20)
        }
      }
      
      ext {
        junitVersion = '5.9.2'
      }
      
      sourceCompatibility = '20'
      targetCompatibility = '20'
      
      tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
      }
      
      application {
        mainModule = 'com.mmp.mmp_javafx_test1'
        mainClass = 'com.mmp.mmp_javafx_test1.HelloApplication'
      }
      
      javafx {
        version = '20'
        modules = ['javafx.controls', 'javafx.fxml']
      }
      
      dependencies {
      
        testImplementation("org.junit.jupiter:junit-jupiter-api:${junitVersion}")
        testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:${junitVersion}")
      }
      
      test {
        useJUnitPlatform()  }
      
      jlink {
        imageZip = project.file("${buildDir}/distributions/app-${javafx.platform.classifier}.zip")
        options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']
        launcher {
          name = 'app'
        }
      }
      
      jlinkZip {
        group = 'distribution'
      }
  === END ===
  [FILE] MMP_JavaFX_test1.iml
  === Content of MMP_JavaFX_test1.iml ===
      <?xml version="1.0" encoding="UTF-8"?>
      <module type="JAVA_MODULE" version="4">
        <component name="NewModuleRootManager" inherit-compiler-output="true">
          <exclude-output />
          <content url="file://$MODULE_DIR$">
            <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
          </content>
          <orderEntry type="inheritedJdk" />
          <orderEntry type="sourceFolder" forTests="false" />
          <orderEntry type="library" exported="" name="MMP_JavaFX_test1-1.0-SNAPSHOT" level="project" />
          <orderEntry type="library" exported="" name="gradle-wrapper" level="project" />
        </component>
      </module>
  === END ===
  [FILE] settings.gradle
  === Content of settings.gradle ===
      rootProject.name = "MMP_JavaFX_test1"
  === END ===
[DIR] src
  [DIR] main
    [DIR] java
      [FILE] module-info.java
      === Content of src\main\java\module-info.java ===
          module com.mmp.mmp_javafx_test1 {
              requires javafx.controls;
              requires javafx.fxml;
                      
                                      
              opens com.mmp.mmp_javafx_test1 to javafx.fxml;
              exports com.mmp.mmp_javafx_test1;
          }
      === END ===
      [DIR] com
        [DIR] mmp
          [DIR] mmp_javafx_test1
            [FILE] AStarSolver.java
            === Content of src\main\java\com\mmp\mmp_javafx_test1\AStarSolver.java ===
                package com.mmp.mmp_javafx_test1;
                
                import java.util.*;
                
                public class AStarSolver {
                    private final Graph graph;
                    private final Graph.Node start, end;
                
                    public AStarSolver(Graph graph, Graph.Node start, Graph.Node end) {
                        this.graph = graph;
                        this.start = start;
                        this.end = end;
                    }
                
                    // Add this method to calculate heuristic (Manhattan distance)
                    private int heuristic(Graph.Node a, Graph.Node b) {
                        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
                    }
                
                    //uses lambda to priotitise by g, this is a placeholder for when i upgrade from djkstra to A*
                    public List<Graph.Node> findPath() {
                        PriorityQueue<NodeWrapper> openSet = new PriorityQueue<>(Comparator.comparingInt(n -> n.f));
                        Map<Graph.Node, NodeWrapper> allNodes = new HashMap<>();
                
                        NodeWrapper startWrapper = new NodeWrapper(start, 0, end);
                        openSet.add(startWrapper);
                        allNodes.put(start, startWrapper);
                
                        while (!openSet.isEmpty()) {
                            NodeWrapper current = openSet.poll();
                
                            //this prevents the algorithm from showing all visited nodes
                            if (current.node.equals(end)) {
                                return reconstructPath(current);
                            }
                
                            for (Graph.Node neighbor : graph.getNeighbors(current.node)) {
                                int tentativeG = current.g + 1;
                                //need to start commenting. Checks to see
                                //research to see if the update step for dijksra's is needed or if its an oversimplification.
                                NodeWrapper neighborWrapper = allNodes.computeIfAbsent(neighbor,
                                        n -> new NodeWrapper(n, Integer.MAX_VALUE, end));
                
                                if (tentativeG < neighborWrapper.g) {
                                    neighborWrapper.g = tentativeG;
                                    neighborWrapper.f = tentativeG + heuristic(neighbor, end);
                                    neighborWrapper.parent = current;
                
                                    if (!openSet.contains(neighborWrapper)) {
                                        openSet.add(neighborWrapper);
                                    }
                                }
                            }
                        }
                        return Collections.emptyList();
                    }
                
                    private List<Graph.Node> reconstructPath(NodeWrapper node) {
                        List<Graph.Node> path = new ArrayList<>();
                        while (node != null) {
                            path.add(node.node);
                            node = node.parent;
                        }
                        Collections.reverse(path);
                        return path;
                    }
                
                    //static to keep seperate from graph class
                    //nodes can exist seperately from graph
                    //doesn't need an instace of graph
                    //adjaceny lists are handeled seperate from the node class
                    private class NodeWrapper {
                        Graph.Node node;
                        int g; // Cost from start
                        int f; // Total cost (g + h)
                        NodeWrapper parent;
                
                        NodeWrapper(Graph.Node node, int g, Graph.Node end) {
                            this.node = node;
                            this.g = g;
                            this.f = g + heuristic(node, end);
                        }
                    }
                }
            === END ===
            [FILE] Graph.java
            === Content of src\main\java\com\mmp\mmp_javafx_test1\Graph.java ===
                package com.mmp.mmp_javafx_test1;
                
                import java.util.*;
                
                public class Graph {
                
                    //Need to be able to explain
                    final Map<Node, List<Node>> adjacencyList = new HashMap<>();
                
                    // Adds a bidirectional edge between two nodes (maze paths are undirected)
                
                
                
                    //The use of Lambda functions in my code was inspired by
                    public void addEdge(Node node1, Node node2) {
                        adjacencyList.computeIfAbsent(node1, k -> new ArrayList<>()).add(node2);
                        adjacencyList.computeIfAbsent(node2, k -> new ArrayList<>()).add(node1);
                        // Add both ways
                    }
                
                    // Returns all neighbors of a node (connected maze paths)
                    public List<Node> getNeighbors(Node node) {
                        return adjacencyList.getOrDefault(node, new ArrayList<>()); // Return empty list if no neighbors
                    }
                
                    // Represents a maze cell/node with coordinates (x,y)
                    public static class Node {
                        final int x;
                        final int y;
                
                        public Node(int x, int y) {
                            this.x = x;
                            this.y = y;
                        }
                
                        // Equality based on coordinates for proper hashing in adjacencyList
                        @Override
                        public boolean equals(Object o) {
                            if (this == o) return true;
                            if (o == null || getClass() != o.getClass()) return false;
                            Node node = (Node) o;
                            return x == node.x && y == node.y;
                        }
                
                        // HashCode uses coordinates to ensure consistent hashing
                        @Override
                        public int hashCode() {
                            return Objects.hash(x, y);
                        }
                    }
                }
                
            === END ===
            [FILE] HelloApplication.java
            === Content of src\main\java\com\mmp\mmp_javafx_test1\HelloApplication.java ===
                package com.mmp.mmp_javafx_test1;
                
                import javafx.application.Application;
                import javafx.fxml.FXMLLoader;
                import javafx.scene.Scene;
                import javafx.scene.layout.VBox;
                import javafx.stage.Stage;
                
                import java.io.IOException;
                import java.util.List;
                
                public class HelloApplication extends Application {
                
                    @Override
                    public void start(Stage stage) throws IOException {
                        FXMLLoader fxmlLoader = new FXMLLoader(HelloApplication.class.getResource("hello-view.fxml"));
                        Scene scene = new Scene(fxmlLoader.load(), 800, 600);
                        stage.setTitle("Maze Generator");
                        stage.setScene(scene);
                
                        // Generate maze
                        MazeGenerator generator = new MazeGenerator(20, 15);
                        Graph mazeGraph = generator.generate();
                
                        // Create maze grid
                        MazeGrid mazeGrid = new MazeGrid(mazeGraph, 20, 15, 30);
                
                        // Set start and end nodes
                        Graph.Node start = new Graph.Node(0, 0);
                        Graph.Node end = new Graph.Node(19, 14);
                        mazeGrid.setStartNode(start);
                        mazeGrid.setEndNode(end);
                
                        // Solve maze
                        AStarSolver solver = new AStarSolver(mazeGraph, start, end);
                        List<Graph.Node> path = solver.findPath();
                        mazeGrid.highlightPath(path);
                
                        // Add to scene
                        VBox root = (VBox) scene.getRoot();
                        root.getChildren().add(mazeGrid);
                
                        stage.show();
                    }
                
                    public static void main(String[] args) {
                        launch();
                    }
                }
                
            === END ===
            [FILE] HelloController.java
            === Content of src\main\java\com\mmp\mmp_javafx_test1\HelloController.java ===
                /* Old code, Change this back it it doesnt work
                             package com.mmp.mmp_javafx_test1;
                
                             import javafx.fxml.FXML;
                             import javafx.scene.control.Label;
                
                             public class HelloController {
                                 @FXML
                                 private Label welcomeText;
                
                                 @FXML
                                 protected void onHelloButtonClick() {
                                     welcomeText.setText("Welcome to JavaFX Application!");
                                 }
                             }
                             */
                // src/main/java/com/mmp/mmp_javafx_test1/HelloController.java
                package com.mmp.mmp_javafx_test1;
                
                import javafx.fxml.FXML;
                import javafx.scene.control.Label;
                import javafx.scene.layout.GridPane;
                import javafx.scene.shape.Rectangle;
                import javafx.scene.paint.Color;
                
                public class HelloController {
                    @FXML
                    private Label welcomeText;
                
                    private HelloApplication application;
                
                    public void setApplication(HelloApplication application) {
                        this.application = application;
                    }
                
                    @FXML
                    protected void generateNewMaze() {
                        // Implement new maze generation logic
                        welcomeText.setText("New maze generated!");
                    }
                }
                
            === END ===
            [FILE] MazeCell.java
            === Content of src\main\java\com\mmp\mmp_javafx_test1\MazeCell.java ===
                
                package com.mmp.mmp_javafx_test1;
                import javafx.application.Application;
                import javafx.fxml.FXMLLoader;
                import javafx.scene.Scene;
                import javafx.scene.layout.*;
                import javafx.scene.paint.Color;
                import javafx.stage.Stage;
                
                
                
                // MazeCell.java
                    //can just feed the graph through and then see what are connected
                    public class MazeCell extends StackPane {
                        private final int size;
                        private final Graph.Node node;
                        private BorderStroke topBorder;
                        private BorderStroke bottomBorder;
                        private BorderStroke leftBorder;
                        private BorderStroke rightBorder;
                
                        public MazeCell(Graph.Node node, int size) {
                            this.node = node;
                            this.size = size;
                            setStyle("-fx-background-color: white;");
                            setPrefSize(size, size);
                
                            // Initialize all borders
                            topBorder = new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                            rightBorder = new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                            bottomBorder = new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                            leftBorder = new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                
                            setBorder(new Border(topBorder, rightBorder, bottomBorder, leftBorder));
                        }
                
                        //new methods to control borders
                
                        public void setRightBorderVisible(boolean visible) {
                            rightBorder = visible ?
                                    new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.DEFAULT) :
                                    new BorderStroke(Color.TRANSPARENT, BorderStrokeStyle.NONE, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                            updateBorders();
                        }
                
                        public void setLeftBorderVisible(boolean visible) {
                            leftBorder = visible ?
                                    new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.DEFAULT) :
                                    new BorderStroke(Color.TRANSPARENT, BorderStrokeStyle.NONE, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                            updateBorders();
                        }
                
                        public void setBottomBorderVisible(boolean visible) {
                            bottomBorder = visible ?
                                    new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.DEFAULT) :
                                    new BorderStroke(Color.TRANSPARENT, BorderStrokeStyle.NONE, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                            updateBorders();
                        }
                
                        public void setTopBorderVisible(boolean visible) {
                            topBorder = visible ?
                                    new BorderStroke(Color.BLACK, BorderStrokeStyle.SOLID, CornerRadii.EMPTY, BorderWidths.DEFAULT) :
                                    new BorderStroke(Color.TRANSPARENT, BorderStrokeStyle.NONE, CornerRadii.EMPTY, BorderWidths.DEFAULT);
                            updateBorders();
                        }
                
                        private void updateBorders() {
                            setBorder(new Border(topBorder, rightBorder, bottomBorder, leftBorder));
                        }
                
                
                    public void markAsPath() {
                        setStyle("-fx-background-color: #00ff00; -fx-border-color: #00cc00; -fx-border-width: 1px;");
                    }
                
                    public void markAsStart() {
                        setStyle("-fx-background-color: #005ce6; -fx-border-color: white; -fx-border-width: 2px;");
                    }
                
                    public void markAsEnd() {
                        setStyle("-fx-background-color: #ff4444; -fx-border-color: white; -fx-border-width: 2px;");
                    }
                
                
                    }
                
                
                // MazeGrid.java
                
                
            === END ===
            [FILE] MazeGenerator.java
            === Content of src\main\java\com\mmp\mmp_javafx_test1\MazeGenerator.java ===
                package com.mmp.mmp_javafx_test1;
                
                import java.util.ArrayList;
                import java.util.List;
                import java.util.Random;
                import java.util.Stack;
                
                public class MazeGenerator {
                    private final int width, height;
                    private final boolean[][] visited; // Tracks visited cells during generation
                    private final Graph graph = new Graph(); // Stores maze structure
                
                    public MazeGenerator(int width, int height) {
                        this.width = width;
                        this.height = height;
                        this.visited = new boolean[height][width]; // Initialize visitation grid
                    }
                
                    // Generates a maze using recursive backtracking algorithm
                    public Graph generate() {
                        Random rand = new Random();
                        Stack<Graph.Node> stack = new Stack<>();
                        Graph.Node start = new Graph.Node(0, 0);
                        visited[0][0] = true;
                        stack.push(start);
                
                        while (!stack.isEmpty()) {
                            Graph.Node current = stack.pop(); // Backtracking step
                            List<Graph.Node> neighbors = getUnvisitedNeighbors(current);
                
                            if (!neighbors.isEmpty()) {
                                stack.push(current); // Push current back to backtrack later
                                Graph.Node next = neighbors.get(rand.nextInt(neighbors.size())); // Random neighbor
                                graph.addEdge(current, next); // Create path between nodes
                                visited[next.y][next.x] = true; // Mark as visited
                                stack.push(next); // Continue exploring from new node
                            }
                        }
                        return graph;
                    }
                
                    // Finds unvisited neighbors in all 4 directions (up, down, left, right)
                    private List<Graph.Node> getUnvisitedNeighbors(Graph.Node node) {
                        List<Graph.Node> neighbors = new ArrayList<>();
                        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up
                
                        for (int[] dir : directions) {
                            int nx = node.x + dir[0];
                            int ny = node.y + dir[1];
                
                            if (nx >= 0 && ny >= 0 && nx < width && ny < height && !visited[ny][nx]) {
                                neighbors.add(new Graph.Node(nx, ny));
                            }
                        }
                        return neighbors;
                    }
                }
                
            === END ===
            [FILE] MazeGrid.java
            === Content of src\main\java\com\mmp\mmp_javafx_test1\MazeGrid.java ===
                package com.mmp.mmp_javafx_test1;
                
                import javafx.scene.layout.GridPane;
                import javafx.application.Application;
                import javafx.fxml.FXMLLoader;
                import javafx.scene.Scene;
                import javafx.scene.layout.*;
                import javafx.scene.paint.Color;
                import javafx.stage.Stage;
                
                
                import java.util.HashMap;
                import java.util.List;
                import java.util.Map;
                
                
                public class MazeGrid extends GridPane {
                    private final Map<Graph.Node, MazeCell> cellMap = new HashMap<>();
                    private final int cellSize;
                    private Graph mazeGraph;
                    // In MazeGrid constructor
                
                
                    public MazeGrid(Graph graph, int width, int height, int cellSize) {
                
                        this.cellSize = cellSize;
                        for (int y = 0; y < height; y++) {
                            for (int x = 0; x < width; x++) {
                                Graph.Node node = new Graph.Node(x, y);
                                MazeCell cell = new MazeCell(node, cellSize);
                                cellMap.put(node, cell);
                                add(cell, x, y);
                            }
                        }
                
                        // Connect cells based on graph edges
                
                        for (int y = 0; y < height; y++) {
                            for (int x = 0; x < width; x++) {
                                Graph.Node current = new Graph.Node(x, y);
                                MazeCell currentCell = cellMap.get(current);
                
                                // Check right neighbor
                                if (x < width - 1) {
                                    Graph.Node rightNode = new Graph.Node(x + 1, y);
                                    if (graph.getNeighbors(current).contains(rightNode)) {
                                        currentCell.setRightBorderVisible(false);
                                        MazeCell rightCell = cellMap.get(rightNode);
                                        rightCell.setLeftBorderVisible(false);
                                    }
                                }
                
                                // Check bottom neighbor
                                if (y < height - 1) {
                                    Graph.Node bottomNode = new Graph.Node(x, y + 1);
                                    if (graph.getNeighbors(current).contains(bottomNode)) {
                                        currentCell.setBottomBorderVisible(false);
                                        MazeCell bottomCell = cellMap.get(bottomNode);
                                        bottomCell.setTopBorderVisible(false);
                                    }
                                }
                            }
                        }
                
                
                    }
                
                
                    //this needs to be much more complex, it can traverse and highlight the list with some case statements.
                    //need to implement tests
                    public void highlightPath(List<Graph.Node> path) {
                        path.forEach(node -> {
                            if (cellMap.containsKey(node)) {
                                cellMap.get(node).markAsPath();
                            }
                        });
                    }
                
                    public void setStartNode(Graph.Node start) {
                        if (cellMap.containsKey(start)) {
                            cellMap.get(start).markAsStart();
                        }
                    }
                
                    public void setEndNode(Graph.Node end) {
                        if (cellMap.containsKey(end)) {
                            cellMap.get(end).markAsEnd();
                        }
                    }
                }
                
            === END ===
    [DIR] resources
      [DIR] com
        [DIR] mmp
          [DIR] mmp_javafx_test1
            [FILE] hello-view.fxml
            === Content of src\main\resources\com\mmp\mmp_javafx_test1\hello-view.fxml ===
                <?xml version="1.0" encoding="UTF-8"?>
                
                <?import javafx.scene.layout.VBox?>
                <?import javafx.scene.control.Button?>
                <?import javafx.scene.control.Label?>
                <?import javafx.geometry.Insets?>
                
                <VBox alignment="CENTER" spacing="20.0" xmlns:fx="http://javafx.com/fxml"
                      fx:controller="com.mmp.mmp_javafx_test1.HelloController">
                  <padding>
                    <Insets bottom="20.0" left="20.0" right="20.0" top="20.0"/>
                  </padding>
                
                  <Label fx:id="welcomeText" text="Maze Generator"/>
                  <Button text="Generate New Maze" onAction="#generateNewMaze"/>
                </VBox>
            === END ===